-----
### Red-Black Tree
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/d045cc55-b9fd-483e-9a5f-0aab30fb5d30">
</div>

1. 이진 탐색 트리의 규칙을 가지고 있으며, AVL 트리와 비슷하게 스스로 균형을 잡는 이진 탐색 트리
2. 삽입 / 삭제 시 노드가 가지고 있는 색깔을 이용한 규칙을 통해 불균형을 완화하는 트리

-----
### 시간 복잡도
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/f6b64f11-1243-4abe-8fab-a61675c01540">
</div>
  - 밑이 2인 로그를 뜻함

-----
### AVL 트리와의 차이점
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/5c35d090-cb44-409f-ad9f-6e74a4eecdbb">
</div>

1. AVL 트리보다는 균형을 엄격하게 맞추지 않음
2. 노드의 재배치를 빈번하게 실행하지 않기 때문에, 삽입 / 삭제의 연산이 많은 경우 AVL 트리보다 평균적으로 더 나은 성능을 가짐
3. AVL 트리보다 덜 균형하기 때문에, 평균적인 탐색 횟수는 AVL 트리보다 더 많을 수 있음
4. 따라서, 삽입 / 삭제 연산이 빈번할 경우 Red-Black 트리를 이용하는 것이 좀 더 낫고, 삽입 / 삭제 연산이 빈번하지 않고, 탐색 성능이 더 중요하면 AVL 트리를 이용하는 것이 더 좋음

-----
### Red-Black 트리 규칙
-----
1. 모든 노드는 빨강 또는 검정
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/75217429-e9da-4f17-bbe2-77e6c0761b60">
</div>

  - Red-Black 트리는 빨강 또는 검정으로 이루어져 있는 노드
  - 빨강과 검정 외 색깔의 노드는 존재하지 않음

2. 루트 노드는 항상 검정
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/8f6d25c0-18db-4fa4-ae29-3d8a3f420cd4">
</div>

  - Red-Black 트리에서 삽입 / 삭제로 인한 노드의 재배치가 실행될 때 일시적으로 루트 노드가 빨강 노드가 될 수 있음
  - 하지만, 최종적으로는 항상 검정 노드여야 함

3. 모든 Leaf 노드는 루트 노드와 동일한 색상을 가짐
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/09118ab5-7752-4075-a58c-498277084754">
</div>

  - Red-Black 트리는 Leaf 노드로 논리적인 Null 를 가짐
  - 이 논리적인 Null Leaf 노드는 항상 검정색

4. 모든 빨강 노드의 자식은 검정 노드
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/51a9f37f-d26a-4d2c-b79d-1d19bed48219">
</div>

  - 빨강 노드의 자식 노드로 검정 노드만 배치 가능
  - 빨강 노드의 자식 노드로 빨강 노드가 오는 것을 Doubled Red라고 부름
  - 해당 규칙을 어기면 노드 재배치 실행

<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/2abbea1f-45e8-438d-afd6-b8fe0f4edcf6">
</div>

  - 검정 노드의 자식이 검정 노드일 수 있음
  - 하지만, 빨강 노드의 자식이 빨강 노드인 Red-Black 트리는 존재하지 않음

5. 주어진 노드에서 후손 노드로 가는 모든 단순 경로에는 동일한 수의 검정색 노드가 존재
   - 1번 노드를 거쳐 Leaf 노드로 가는 경우 : 2개의 검정색 노드를 가짐
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/fdb764fc-5890-48f8-800e-2c1f74f8a08b">
</div>

   - 4번 노드를 거쳐 Leaf 노드로 가는 경우 : 2개의 검정색 노드를 가짐
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/c60e8108-009d-466f-a99a-fd7613a947ce">
</div>

   - 3번 노드를 거쳐 Leaf 노드로 가는 경우 : 2개의 검정색 노드를 가짐
   - 우측 자식은 1개의 검정색 노드를 가지므로 재배치 필요
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/c7a62a56-e231-4773-8cca-947765845bfe">
</div>

<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/8ffe4624-bf14-4b49-9ffc-34b49df8d1c5">
</div>

  - 특정 노드 기준으로 Leaf 노드로 가는 모든 경로를 봤을 떄, 항상 동일한 수의 검정 노드가 존재해야 함
  - 예를 들어, 루트 노드를 포함하여 Leaf 노드로 가는 모든 경로를 살펴봤을 때, 검정 노드의 수는 항상 3개
  - 또 다른 예시로, 4번 노드를 기준으로 Leaf 노드까지의 경로를 살펴봤을 때, 검정 노드의 수는 항상 2개
  - '모든 빨강 노드의 자식은 검정 노드'와 '5번 규칙'에 의해 노드 재배치가 실행

-----
### Red-Black 트리의 삽입
-----
1. 이진 탐색 트리의 확장판으로 노드를 삽입하는 과정은 동일하나 Red-Black 트리의 규칙을 유지하기 위해 추가적 재배치가 실행될 수 있음
2. 규칙
```
A. 삽입 시 이진 탐색 트리의 규칙에 의해 노드의 위치가 정해지며, 빨강 노드로 삽입
B. Red-Black 트리 규칙에 의해 삽입된 위치에서 부모 노드가 빨강 노드인 경우 재배치 실행 (Doubled Red)
C. 루트 노드인 경우 해당 노드를 검정색으로 변경
```

3. 노드가 재배치되는 상황
```
A. 삼촌 Red, 우측-우측 Double Red
B. 삼촌 Red, 우측-좌측 Double Red
C. 삼촌 Black, 우측-우측 Double Red
D. 삼촌 Black, 우측-좌측 Double Red
```
  - 좌측 Doubled Red 상황과 해결 방법이 대칭됨

-----
### Red-Black 삽입 경우 1 - 삼촌 Red, 우측-우측 Double Red (Recoloring)
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/d81a9f0e-29e4-4639-a4a4-a989001bae88">
</div>

1. '모든 빨강 노드의 자식은 검정 노드' 규칙 위배된 상황
   - 부모(p)가 빨강, 삼촌(u)이 빨강, 부모의 우측 자식(x)으로 빨강 노드가 삽입된 경우
2. 이 경우, 노드의 색깔만 변경하는 방식 사용
```
A. 조부모 노드(g)의 색깔을 빨강으로 변경
B. 삼촌 노드(u)와 부모 노드(p)의 색깔을 검정으로 변경
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/3d3b9ba2-2b14-48b0-97db-3bc160e491c4">
</div>

3. 이렇게 변경하면, '주어진 노드에서 후손 Leaf 노드로 가는 모든 단순 경로에는 동일한 수의 검정색 노드가 존재'와 '모든 빨강 노드의 자식은 검정 노드' 규칙 유지

-----
### Red-Black 삽입 경우 2 - 삼촌 Red, 우측-좌측 Double Red (Recoloring)
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/1f343f48-85ff-47e7-8b70-03fe43456e58">
</div>

1. 부모(p)가 빨강, 삼촌(u)이 빨강, 부모의 좌측 자식(x)으로 빨강 노드가 삽입된 경우

<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/a10660f0-3110-4682-aa08-34613b90c617">
</div>

2. 좌측 자식(x)으로 빨강 노드가 삽입된 경우와 마찬 가지로 똑같은 방법을 사용

-----
### Red-Black 삽입 경우 3 - 삼촌 Black, 우측-우측 Double Red (Restructuring)
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/48d375e4-c438-4dc0-a473-9305ae27a4a4">
</div>

1. '모든 빨강 노드의 자식은 검정 노드' 규칙을 위배한 상황
   - 부모(p)가 빨강, 삼촌(u)이 검정, 부모의 우측 자식(x)으로 빨강 노드가 삽입

2. 이 경우에는, 노드를 회전 시키는 방식 사용
```
A. 조부모 노드(g)와 부모 노드(p)의 색깔을 SWAP
B. 부모 노드(p)를 축으로 Left-Rotation 실행 (AVL 트리의 RR 회전과 동일)
```
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/6838f3f7-2dac-4400-9ca7-e99f73fcd22a">
</div>

3. '주어진 노드에서 후손 Leaf 노드로 가는 모든 단순 경로에는 동일한 수의 검정색 노드가 존재한다'와 '모든 빨강 노드의 자식은 검정 노드' 규칙 유지 가능

-----
### Red-Black 삽입 경우 4 - 삼촌 Black, 우측-좌측 Double Red (Restructuring)
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/b451fa51-97e5-485a-8195-f4ca6ed1ad83">
</div>

1. '모든 빨강 노드의 자식은 검정 노드'라는 규칙 위배
   - 부모(p)가 빨강, 삼촌(u)이 검정, 부모의 좌측 자식(x)으로 빨강 노드가 삽입된 경우

2. 노드를 회전 시키는 방식 사용
```
A. 부모 노드(p)를 축으로 Right-Rotation 실행 (AVL 트리의 LL 회전과 동일)
B. 조부모 노드(g)와 새로운 부모 노드의 색깔을 SWAP
C. 새로운 부모 노드를 축으로 Left-Rotation 실행 (AVL 트리의 RR 회전과 동일)
```

  - 결론적으로 색깔을 변경하는 것을 제외하고, AVL 트리의 RL 회전과 동일한 방식으로 회전

<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/184b2ab0-d517-421a-a2bb-432be040a8c6">
</div>

3. 부모 노드(p)를 축으로 Right-Rotation을 실행 (AVL 트리의 LL 회전과 동일)

<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/a85fd98d-d9e1-4b69-a770-7b94a2561b99">
</div>

4. Right-Rotation이 실행된 후, 새로운 부모 노드(x)와 조부모 노드의(g)의 색깔을 SWAP
5. 그리고 새로운 부모 노드(x)를 축으로 Left-Rotation을 실행 (이 부분은 AVL 트리의 RR 회전과 동일)

<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/04b20fee-ef45-430c-85e6-76f8dc799529">
</div>

6. 중간에 색깔을 변경하는 것을 제외하고는 AVL 트리 회전과 동일

-----
### 재배치가 발생하더라도 경로상 검정 노드의 개수는 유지
-----
<div align="center">
<img src="https://github.com/sooyounghan/Java/assets/34672301/12f299f8-f1f1-43d8-9005-9e1c803caa0d">
</div>

1. 삽입으로 인해 재배치가 발생하여 혹시나 전체 트리 기준으로 '주어진 노드에서 후손 Leaf 노드로 가는 모든 단순 경로에는 동일한 수의 검정 노드가 존재'가 위배되는가?
2. 재배치를 실행하더라도 경로상 검정 노드의 개수는 유지


-----
### Red-Black Tree 삽입 코드
-----
1. Node
```java
public class Node {
	int key; // Node의 값
	Node left, right, parent; // 좌측, 우측, 부모 노드
	int color = RED; // 기본 노드의 색은 빨강
	
	static final int RED = 0;
	static final int BLACK = 1;
}
```

2. RedBlackTree
```java
package Red_Black;

import static Red_Black.Node.BLACK;
import static Red_Black.Node.RED;

public class RedBlackTree {

    private Node root;

    public void add(int key) {
        Node newNode = new Node();
       
        newNode.key = key;
        
        if (null == root) {
            root = newNode;
        } else {
            insertNode(root, newNode);
        }
        
        root.color = BLACK;
    }

    private void insertNode(Node x, Node newNode) {

        if (x.key > newNode.key && !isExist(x.left)) {
            x.left = newNode;
            newNode.parent = x;
        } else if (x.key <= newNode.key && !isExist(x.right)) {
            x.right = newNode;
            newNode.parent = x;
        } else if (x.key > newNode.key) {
            insertNode(x.left, newNode);
        } else {
            insertNode(x.right, newNode);
        }
        insertFixUp(x);
    }
    
    private boolean isRed(Node x) {
        return isExist(x) && RED == x.color;
    }

    private boolean isBlack(Node x) {
        return !isExist(x) || BLACK == x.color;
    }

    private boolean isExist(Node x) {
        return null != x;
    }

    private void insertFixUp(Node g) {
        if (isRed(g.right) && isRed(g.right.left) && isBlack(g.left)) {
            // RL회전
            LL_rotate(g.right);
            swapColor(g, g.right);
            RR_rotate(g);
        } else if (isRed(g.right) && isRed(g.right.right) && isBlack(g.left)) {
            // RR회전
            swapColor(g, g.right);
            RR_rotate(g);
        } else if (isRed(g.right) && (isRed(g.right.right) || isRed(g.right.left))) {
            // recoloring
            g.color = RED;
            g.right.color = BLACK;
            g.left.color = BLACK;
        } else if (isRed(g.left) && isRed(g.left.right) && isBlack(g.right)) {
            // LR회전
            RR_rotate(g.left);
            swapColor(g, g.left);
            LL_rotate(g);
        } else if (isRed(g.left) && isRed(g.left.left) && isBlack(g.right)) {
            // LL회전
            swapColor(g, g.left);
            LL_rotate(g);
        } else if (isRed(g.left) && (isRed(g.left.left) || isRed(g.left.right))) {
            // recoloring
            g.color = RED;
            g.left.color = BLACK;
            g.right.color = BLACK;
        }
    }

    private void swapColor(Node nodeA, Node nodeB) {
        int color = nodeA.color;
        nodeA.color = nodeB.color;
        nodeB.color = color;
    }

    public int search(int key) {
        return searchNode(root, key).key;
    }

    private Node searchNode(Node parent, int key) {
        if (null == parent) {
            throw new RuntimeException("노드를 찾을 수 없습니다.");
        } else if (parent.key > key) {
            parent = searchNode(parent.left, key);
        } else if (parent.key < key) {
            parent = searchNode(parent.right, key);
        }
        return parent;
    }

    private void LL_rotate(Node P) {
        /**
         * 축(L)을 중심으로 우측으로 끌어당긴다.
         *     GP(?) or GP(?)    GP(?) or GP(?)
         *         ↘    ↙          ↘    ↙
         *          P(4)    =>      L(2)
         *        ↙                ↙    ↘
         *     L(2)             LL(1)    P(4)
         *    ↙    ↘                    ↙
         * LL(1)   LR(3)            LR(3)
         */
        // TODO : 아래(부모 -> 자식)로 향하는 포인터 재설정
        Node GP = P.parent;
        Node L = P.left;
        Node LR = L.right;
        L.right = P;
        P.left = LR;

        // TODO : 위(자식 -> 부모)로 향하는 포인터 재설정
        P.parent = L;
        if (isExist(LR)) {
            LR.parent = P;
        }

        // TODO : 위(부모 -> 조부모)로 향하는 포인터 재설정
        L.parent = GP;

        // TODO : 아래(조부모->부모)로 향하는 포인터 재설정
        if (!isExist(GP)) {
            this.root = L;
        } else {
            /**
             * 만약에 조부모가 있을경우
             * 부모가 조부모의 어느 자식(좌,우)인지 모른다.
             * 조부모의 이전 자식이 부모 노드였으므로 동일한
             * 링크를 찾으면 조부모의 어느 자식(좌,우)인지 찾을 수 있다.
             */
            if (GP.right == P) {
                GP.right = L;
            } else if (GP.left == P) {
                GP.left = L;
            }
        }
    }

    private void RR_rotate(Node P) {
        /**
         * 축을(R) 중심으로 좌측으로 끌어당긴다.
         * GP(?) or GP(?)       GP(?) or GP(?)
         *     ↘    ↙               ↘    ↙
         *      P(1)        =>       R(3)
         *         ↘                ↙    ↘
         *          R(3)        P(1)      RR(4)
         *         ↙    ↘           ↘
         *      RL(2)   RR(4)        RL(2)
         */
        // TODO : 아래(부모 -> 자식)로 향하는 포인터 재설정
        Node GP = P.parent;
        Node R = P.right;
        Node RL = R.left;
        R.left = P;
        P.right = RL;

        // TODO : 위(자식 -> 부모)로 향하는 포인터 재설정
        P.parent = R;
        if (isExist(RL)) {
            RL.parent = P;
        }

        // TODO : 위(부모 -> 조부모)로 향하는 포인터 재설정
        R.parent = GP;

        // TODO : 아래(조부모->부모)로 향하는 포인터 재설정
        if (!isExist(GP)) {
            this.root = R;
        } else {
            /**
             * 만약에 조부모가 있을경우
             * 부모가 조부모의 어느 자식(좌,우)인지 모른다.
             * 조부모의 이전 자식이 부모 노드였으므로 동일한
             * 링크를 찾으면 조부모의 어느 자식(좌,우)인지 찾을 수 있다.
             */
            if (GP.right == P) {
                GP.right = R;
            } else if (GP.left == P) {
                GP.left = R;
            }
        }
    }

    private void printHelper(Node root, String indent, boolean last) {
        if (root != null) {
            System.out.print(indent);
            if (last) {
                System.out.print("R----");
                indent += "   ";
            } else {
                System.out.print("L----");
                indent += "|  ";
            }

            String sColor = root.color == RED ? "RED" : "BLACK";
            System.out.println(root.key + "(" + sColor + ")");
            printHelper(root.left, indent, false);
            printHelper(root.right, indent, true);
        }
    }

    public void printTree() {
        printHelper(this.root, "", true);
    }

    public void traversal() {
        inorderTraversal(root);
        System.out.println("");
    }

    private void inorderTraversal(Node node) {
        if (null == node) {
            return;
        }
        inorderTraversal(node.left);
        System.out.printf("%d ", node.key);
        inorderTraversal(node.right);
    }
}
```

3. Main
```java
package Red_Black;

public class Main {

    public static void main(String[] args) {
        RedBlackTree redBlackTree = new RedBlackTree();
        redBlackTree.add(5);
        redBlackTree.add(2);
        redBlackTree.add(9);
        redBlackTree.add(3);
        redBlackTree.add(7);
        redBlackTree.add(4);
        redBlackTree.add(8);
        redBlackTree.add(1);
        redBlackTree.add(6);
        redBlackTree.printTree();
        System.out.println("traversal");
        redBlackTree.traversal();

        System.out.println(redBlackTree.search(1));
    }
}
```
