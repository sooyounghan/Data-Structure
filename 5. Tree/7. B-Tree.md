-----
### B-Tree
-----
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/520a62b5-93df-413c-bb07-9bd43976acf3">
</div>

1. 한 노드가 여러 개의 데이터(키)를 가질 수 있으며, 여러 자식 노드를 가질 수 있는 트리
2. 분기 요소(Branching Factor)라는 개념을 통해 노드가 가질 수 있는 데이터와 자식 수가 달라짐

-----
### 분기 요소 (Branching Factor)
-----
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/a4f33bdc-5699-4af8-836f-206bab808462">
</div>

1. 한 노드가 가질 수 있는 키의 수와 자식 노드 수를 정함
2. 분기 요소의 규칙
```
A. 최소 분기 요소 :  2 <= t
B. 키의 수 : t - 1 <= 키의 수 <= 2t - 1
C. 자식 노드 수 : t <= 자식 노드 수 <= 2t
```
3. 루트 노드는 최소 규칙에 제외됨

4. 예) t = 2일 때,
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/71623c2a-422d-479f-a96b-ca76a9310acd">
</div>

  - 최소 분기 요소 : 2 <= t
  - 키의 수 : 1 <= 키의 수 <= 3
  - 자식 노드 수 : 2 <= 자식 노드 수 <= 4

5. 예) t = 3일 때,
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/f51e8e69-43eb-4c2c-9c96-d1c5ed4cb1c0">
</div>

  - 최소 분기 요소 : 2 <= t
  - 키의 수 : 2 <= 키의 수 <= 5
  - 자식 노드 수 : 3 <= 자식 노드 수 <= 6

6. 분기 요소에 따라 트리가 영향을 받음

-----
### 시간 복잡도
-----
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/d856f0cb-0767-43e5-b7b2-dd2860ba2cb4">
</div>
* 밑이 2인 로그를 뜻함

-----
### B-Tree의 특징
-----
1. 분기 요소(Branching Factor)에 의해 한 노드가 가질 수 있는 키의 수와 자식 노드 수가 달라짐
2. 모든 Leaf 노드는 같은 깊이를 가지므로, 균형 잡혀 있는 트리
3. 한 노드에 여러 키를 가질 수 있으므로, 분기 요소가 큰 키일수록 트리의 높이가 낮아짐
4. 분기 요소(t)와 높이(h)에 따른 최대로 보유할 수 있는 트리의 키 개수는 (2t)^(h+1)-1
5. 예) t = 2, h = 1일 때, 키를 3, 4, 5, 1, 2, 6, 8, 9, 7, 10, 12, 13, 11, 14, 15 순서대로 삽입
   - 각 노드가 최대 키 개수를 보유한 높이 1인 트리를 얻을 수 있음

-----
### B-Tree 규칙
-----
1. 특정 키를 기준으로 작은 키는 좌측에, 큰 키는 우측에 배치
   - 즉, 좌측 자식들은 특정 키보다 작은 키들의 모음이고, 우측 자식은 큰 키들의 모음
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/9b2246eb-9c8f-4cc4-ae91-7b61ef85591d">
</div>

   - 따라서, 트리를 중위 순회 하면, 정렬된 키를 얻을 수 있음
   - 또한, Leaf 노드가 아닌 이상, 항상 자식 노드를 가지고 있어야 함
     
2. 모든 Leaf 노드는 같은 깊이를 가짐
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/1d28b494-5504-4e9c-87dc-f9b8578454db">
</div>

  - 모든 Leaf 노드가 같은 깊이를 가진다는 것은 균형 있는 트리
  - 대부분의 키가 Leaf 노드에 존재하므로 키 탐색 시간이 항상 균일한 것을 알 수 있음

3. 분기 요소(t)가 존재하며, 최소 t의 수는 다음과 같음
```
2 <= t
```
  - B-Tree는 분기 요소(t)에 의해 노드가 보유할 수 있는 키가 정해지므로, 분기 요소(t)가 커질 수록, 노드가 더 많은 양의 키를 보유할 수 있음
  - 따라서, 트리의 높이는 줄어듬
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/28a96dfc-df33-4d1d-ba91-64c27d57338c">
<img  src="https://github.com/sooyounghan/Data-Structure/assets/34672301/d5ad7c05-3f46-4c82-a559-4efcce0577f2">
<img  src="https://github.com/sooyounghan/Data-Structure/assets/34672301/5b631030-30b3-4cbb-bfc4-2064b40b90c0">
</div>

4. 루트 노드를 제외한 각 노드의 키의 개수 범위는 다음과 같음
```
t - 1 <= 키의 수 <= 2t - 1
```
5. 삽입 시 : 키의 개수를 2t - 1 개를 초과하면, 분할을 통해 규칙을 유지
   - 즉, 2t가 되면, 분할을 통해 규칙을 유지
   - 즉, 키의 삽입으로 인해 키의 개수가 2t가 되면, 노드가 보유할 수 있는 키의 수 최댓값 초과(Overfull Node)되어 키 보유 규칙을 위해 분할
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/3af0d8f0-d070-4e4e-8e94-cb7ede92ce52">
</div>

   - 노드가 보유하고 있는 키의 중간 값을 찾은 후, 중간 키를 부모 노드로 상승
   - 중간 키를 기준으로 좌측의 키들은 좌측 자식 노드, 우측의 키들은 우측 자식 노드로 분할

6. 삭제 시 : 키의 개수가 t - 1 개 미만이면, 회전 또는 병합을 통해 규칙을 유지
  - 키 삭제 시, 최소 키 규칙을 지키기 위해 회전 또는 병합 작업 실시하여 노드의 최소 키 보유 규칙 유지
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/1a54f352-cd27-4f3f-a0f3-4b1a604d7458">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/033ca019-b7dd-46ad-85a9-1c63725b28ce">
</div>

  - 즉, 형제 노드의 키를 빌려온 후(회전), 삭제하고자 하는 노드 삭제
  - 하지만, 형제 노드의 키를 빌려올 수 없으면(병합), 이를 병합한 후 해당 키를 삭제

7. 각 노드당 키에 따라 가질 수 있는 자식의 범위는 다음과 같음
```
t <= 자식 수 <= 2t
```
  - 노드의 키의 개수가 k개 이면, 자식 노드의 개수는 k + 1개
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/06cc4593-7598-4551-868e-edb3891ed508">
</div>

-----
### B-Tree의 탐색
-----
1. 이진 탐색 트리와 유사
2. 각 노드는 정렬된 데이터로 배치되므로 루트 노드의 키부터 자식 노드의 키까지 탐색
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/6f0eaa28-6165-4969-9d37-9e29a0b0c175">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/7accec5b-33bb-4696-a8ca-37600a26baf5">
</div>

  - 첫 번째 키에 접근하여 찾아야하는 키와 해당 키의 값 비교
  - 찾아야 하는 키보다 큰 값을 만나면, 해당 Key Index에 해당하는 자식 노드로 내려가 탐색하여, 다시 첫 번째 키부터 접근해 탐색

-----
### B-Tree의 삽입
-----
1. 노드의 키는 항상 정렬된 상태로 있어야 함
2. 노드가 최대로 보유할 수 있는 키 (2t - 1)를 초과할 때까지 보관하다가 초과되면 노드를 분할
3. 내부 노드는 분할 시 트리의 높이가 늘어나지 않지만, 루트 노드는 분할 시 높이가 늘어남
4. 💡 B-Tree의 키 삽입은 항상 Leaf 노드에 추가
5. 과정
```
A. 삽입될 키의 위치를 찾아 노드에 키를 삽입
B. 재귀적으로 노드의 키 개수가 2t가 되면 분할
C. 루트 노드를 분할 시 새로운 루트 노드로 변경
```

-----
### B-Tree의 삽입 예제
-----
1. 최초 키 삽입 시 루트 노드를 생성하며, 키를 배치
2. 키가 추가될 때마다 적절한 위치에 삽입
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/b75f21b4-9cd7-4e8b-8992-08105cf6c3ff">
</div>

3. 키 1이 추가되면, 해당 노드의 키가 4개 이므로 분할
4. 분할 시 중간 키를 위로 올리며, 두 개의 노드로 분할되며, 위로 올라간 노드는 새로운 루트 노드가 됨 (깊이가 1인 B-Tree)
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/e927a7a0-5403-4d2f-ad9f-f7a0df0c9a81">
</div>

5. 키 2가 추가되면 해당 노드의 키가 4개이므로 분할
6. 분할 시 중간 키를 위로 올리며, 두 개의 노드로 분할
   - 단, 이미 기존 부모 노드가 존재하므로 이전과 동일하게 분할하되, 부모 노드에 중간키를 삽입
   - 이후, 중간키를 기준으로 분할
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/78567fb7-fb9b-4caf-9fe4-fc8b48333fdc">
</div>

<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/b5783a2a-51cd-41e5-8684-3dc891febfa9">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/a1eced88-26bd-4c44-8db9-88357fb19590">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/ded4c904-cf08-47e9-8a94-579f2cea7453">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/db2fa1dc-94ef-4ba2-ae5f-c78b393bc4cc">
</div>

7. 추가된 키로 인해 노드를 분할하면, 부모 노드까지 영향을 미치며, 부모 노드도 최대 보유 키를 초과하게 되면, 재귀적으로 분할해야 함
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/d696495e-a146-43eb-9a98-0645b038d84c">
</div>

8. 최대 보유 키를 초과한 부모 노드도 중간키를 위로 올리며, 두 개의 노드로 분할
9. 그리고 부모 노드가 루트 노드이므로 새로운 루트 노드를 생성 후 중간 키를 위로 올림
10. 💡 이러한 과정을 거치며 B-Tree의 삽입은 모든 Leaf 노드가 같은 깊이를 가지도록 '상향식 분할이 아닌 상향식 분할'
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/4d10e173-4255-4e60-8e08-ef9ab1ab97ce">
</div>

-----
### B-Tree 코드
-----
1. Node Class
```java
import java.util.ArrayList;
import java.util.List;

class Node {

    List<Integer> keys; // 키 리스트
    List<Node> nodes; // 자식 노드 리스트

    Node(int t) {
        this.keys = new ArrayList<>(2 * t);
        this.nodes = new ArrayList<>(2 * t);
    }
}
```

2. B-Tree Class
```java
public class BTree {
    /**
     * B-Tree
     * t는 페이지 또는 Block 크기. 임의로 사용하고 싶다면 원하는 값을 넣으면 됨
     *
     * 각 노드당 가질 수 있는 키의 범위
     * 1) t-1 <= keys <= 2t-1
     * 루트 노드는 최소 key 제한을 받지 않는다
     * Leaf 노드 또는 내부 노드의 크기가 t-1보다 작아지면 병합을 하고
     * 2t-1보다 커지면 분할을 한다
     *
     * 각 노드당 가질 수 있는 자식 노드의 범위
     * 2) t <= childNodes <= 2t
     * Key의 개수에 따라 각 노드당 가질 수 있는 자식의 범위가 다르다
     * key의 개수를 k라고 하면 항상 각 노드는 k+1의 자식 노드를 가진다
     */

    private final int t;
    private Node root;

    public BTree(int t) {
        this.t = t;
    }

    public void add(int key) { // 키를 추가
        if (root == null) {
            root = new Node(t);
            root.keys.add(key);
        } else {
            root = insertKey(root, key);
        }
    }


    private Node insertKey(Node x, int key) { // 키를 해당 위치에 삽입
        int keyIndex = findKeyIndex(x, key); // 키와 관련된 Index 반환
        if (keyIndex < x.keys.size() && x.keys.get(keyIndex) == key) { // 키의 Index가 키의 개수보다 작거나, 키가 이미 존재하면 예외
            throw new RuntimeException("동일한 키 존재");
        }
        if (isLeafNode(x)) {
            x.keys.add(keyIndex, key);
        } else {
            /**
             * x ->   |..| (parent)
             * y -> |..|..| (child)
             */
            Node y = insertKey(x.nodes.get(keyIndex), key);
            if (y.keys.size() == 2 * t) {
                // Not Root, overfull Node (split 필요)
                x = splitNode(x, y, keyIndex);
            }
        }
        if (root == x && x.keys.size() == 2 * t) {
            // Root, overfull Node (split 필요)
            Node newRoot = new Node(t);
            x = splitNode(newRoot, x, 0);
        }
        return x;
    }

    private Node splitNode(Node x, Node y, int yNodeIndex) { // 노드를 분할
        /**
         * x: 부모 노드
         * y: 자식 노드
         * yNodeIndex: y 노드가 x 노드의 몇 번째 자식인지 알 수 있는 index
         *
         * 분할
         * t = 2
         * 1(t-1) <= keys <= 3(2t-1)
         * 분할 조건 : keys == 4(2t)
         * 중간값(medianKey) = t
         *
         * Ex1. 루트인 경우
         * (1)
         *  x ->   | |
         *  y -> |1|2|3|
         * (2)
         *  x ->   |2|
         *        ↙   ↘
         *  y -> |1| |3| <- z
         *
         * Ex2. 루트가 아닌 경우
         * (1)
         *  x ->   |2|
         *        ↙   ↘
         *  y -> |1| |3|4|5|
         * (2)
         *  x ->    |2|4|
         *         ↙  ↓    ↘
         *  y -> |1| |3|<-z |5|
         */
        Node z = new Node(t);
        int medianKey = y.keys.get(t);
        int yKeySize = y.keys.size();
        int yChildrenSize = y.nodes.size();

        // 새로운 노드에 키 복사
        z.keys.addAll(y.keys.subList(t + 1, yKeySize));
        // 기존 노드에 키 제거
        y.keys.subList(t, yKeySize).clear();

        if (!y.nodes.isEmpty()) {
            // 새로운 노드에 자식 노드 연결
            z.nodes.addAll(y.nodes.subList(t + 1, yChildrenSize));
            // 기존 노드의 자식 노드 제거
            y.nodes.subList(t + 1, yChildrenSize).clear();
        }

        if (root == y) {
            // 새로운 root 노드 생성 후 중간키 삽입
            x.keys.add(medianKey);
            // 새로운 root 노드에 이전 root 노드, 새로운 노드 삽입
            x.nodes.add(y);
            x.nodes.add(z);
        } else {
            // 부모 노드에 중간키 삽입
            x.keys.add(yNodeIndex, medianKey);
            // 부모 노드에 새로운 노드 삽입
            x.nodes.add(yNodeIndex + 1, z);
        }

        return x;
    }

    public int search(int key) { // 키를 찾음
        Node node = searchNode(root, key);
        int keyIndex = node.keys.indexOf(key);
        return node.keys.get(keyIndex);
    }

    private Node searchNode(Node x, int key) { // 노드를 찾음
        int keyIndex = x.keys.indexOf(key);
        if (keyIndex == -1) {
            if (isLeafNode(x)) {
                throw new RuntimeException("찾을 값이 존재하지 않습니다.");
            }
            // x 노드에 key를 찾지 못한 경우 아래로 내려감
            int nodeIndex = findKeyIndex(x, key);
            return searchNode(x.nodes.get(nodeIndex), key);
        } else {
            return x;
        }
    }

    private boolean isLeafNode(Node x) { // Leaf 노드인지 확인
        return x.nodes.isEmpty();
    }

    private int findKeyIndex(Node x, int key) { // 키와 관련된 Index를 찾음
    // 1. i가 키의 개수보다 크면 마지막 자식 노드에 키가 있음
    // 2. i가 키의 개수보다 작으면 자식 노드에 키가 존재하거나 키가 i에 있음
    // 이는, 키의 개수와 자식 노드의 개수의 불일치 때문임 (자식 노드의 개수는 키의 개수보다 1개가 더 많기 때문임)
        int i = 0;
        while (i < x.keys.size() && x.keys.get(i) < key) {
            i++;
        }
        return i;
    }

    public void traversal() {
        inorderTraversal(root);
        System.out.println("");
    }

    private void inorderTraversal(Node node) {
        // 중위 순회
        for (int i = 0; i < node.keys.size(); i++) {
            if (!node.nodes.isEmpty()) {
                inorderTraversal(node.nodes.get(i));
            }
            System.out.printf("%d ", node.keys.get(i));
        }
        if (!node.nodes.isEmpty()) {
            inorderTraversal(node.nodes.get(node.nodes.size() - 1));
        }
    }

    public void printTree() {
        printTree(root, 0, "");
    }

    private void printTree(Node node, int index, String indent) {
        printKey(node, index, indent);
        if (!isLeafNode(node)) {
            for (int i = 0; i < node.nodes.size(); i++) {
                printTree(node.nodes.get(i), i, indent + "  ");
            }
        }
    }

    private void printKey(Node node, int index, String indent) {
        if (root != node) {
            System.out.printf("%sㄴ[C%d] ", indent, index);
        } else {
            System.out.print(" [R] ");
        }
        for (int key : node.keys) {
            System.out.printf("%d ", key);
        }
        System.out.println("");
    }
}
```

3. Main Class
```java
public class Main {

    public static void main(String[] args) {
        BTree bTree = new BTree(2);
        bTree.add(3);
        bTree.add(4);
        bTree.add(5);
        bTree.add(1);
        bTree.add(2);
        bTree.add(6);
        bTree.add(8);
        bTree.add(9);
        bTree.add(7);
        bTree.add(10);
        bTree.add(12);
        bTree.add(13);
        bTree.add(11);
        bTree.add(14);
        bTree.add(15);

        bTree.printTree();
        bTree.traversal();
    }
}
```
