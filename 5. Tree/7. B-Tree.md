-----
### B-Tree
-----
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/520a62b5-93df-413c-bb07-9bd43976acf3">
</div>

1. 한 노드가 여러 개의 데이터(키)를 가질 수 있으며, 여러 자식 노드를 가질 수 있는 트리
2. 분기 요소(Branching Factor)라는 개념을 통해 노드가 가질 수 있는 데이터와 자식 수가 달라짐

-----
### 분기 요소 (Branching Factor)
-----
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/a4f33bdc-5699-4af8-836f-206bab808462">
</div>

1. 한 노드가 가질 수 있는 키의 수와 자식 노드 수를 정함
2. 분기 요소의 규칙
```
A. 최소 노드의 개수 :  2 <= t
B. 키의 수 : t - 1 <= 키의 수 <= 2t - 1
C. 자식 노드 수 : t <= 자식 노드 수 <= 2t
```
3. 루트 노드는 최소 규칙에 제외됨

4. 예) t = 2일 때,
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/71623c2a-422d-479f-a96b-ca76a9310acd">
</div>

  - 최소 노드의 개수 : 2 <= t
  - 키의 수 : 1 <= 키의 수 <= 3
  - 자식 노드 수 : 2 <= 자식 노드 수 <= 4

5. 예) t = 3일 때,
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/f51e8e69-43eb-4c2c-9c96-d1c5ed4cb1c0">
</div>

  - 최소 노드의 수 : 2 <= t
  - 키의 수 : 2 <= 키의 수 <= 5
  - 자식 노드 수 : 3 <= 자식 노드 수 <= 6

6. 분기 요소에 따라 트리가 영향을 받음

-----
### 시간 복잡도
-----
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/d856f0cb-0767-43e5-b7b2-dd2860ba2cb4">
</div>
* 밑이 2인 로그를 뜻함

-----
### B-Tree의 특징
-----
1. 분기 요소(Branching Factor)에 의해 한 노드가 가질 수 있는 키의 수와 자식 노드 수가 달라짐
2. 모든 Leaf 노드는 같은 깊이를 가지므로, 균형 잡혀 있는 트리
3. 한 노드에 여러 키를 가질 수 있으므로, 분기 요소가 큰 키일수록 트리의 높이가 낮아짐
4. 분기 요소(t)와 높이(h)에 따른 최대로 보유할 수 있는 트리의 키 개수는 (2t)^(h+1)-1
5. 예) t = 2, h = 1일 때, 키를 3, 4, 5, 1, 2, 6, 8, 9, 7, 10, 12, 13, 11, 14, 15 순서대로 삽입
   - 각 노드가 최대 키 개수를 보유한 높이 1인 트리를 얻을 수 있음

-----
### B-Tree 규칙
-----
1. 특정 키를 기준으로 작은 키는 좌측에, 큰 키는 우측에 배치
   - 즉, 좌측 자식들은 특정 키보다 작은 키들의 모음이고, 우측 자식은 큰 키들의 모음
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/9b2246eb-9c8f-4cc4-ae91-7b61ef85591d">
</div>

   - 따라서, 트리를 중위 순회 하면, 정렬된 키를 얻을 수 있음
   - 또한, Leaf 노드가 아닌 이상, 항상 자식 노드를 가지고 있어야 함
     
2. 모든 Leaf 노드는 같은 깊이를 가짐
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/1d28b494-5504-4e9c-87dc-f9b8578454db">
</div>

  - 모든 Leaf 노드가 같은 깊이를 가진다는 것은 균형 있는 트리
  - 대부분의 키가 Leaf 노드에 존재하므로 키 탐색 시간이 항상 균일한 것을 알 수 있음

3. 분기 요소(t)가 존재하며, 최소 t의 수는 다음과 같음
```
2 <= t
```
  - B-Tree는 분기 요소(t)에 의해 노드가 보유할 수 있는 키가 정해지므로, 분기 요소(t)가 커질 수록, 노드가 더 많은 양의 키를 보유할 수 있음
  - 따라서, 트리의 높이는 줄어듬
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/28a96dfc-df33-4d1d-ba91-64c27d57338c">
<img  src="https://github.com/sooyounghan/Data-Structure/assets/34672301/d5ad7c05-3f46-4c82-a559-4efcce0577f2">
<img  src="https://github.com/sooyounghan/Data-Structure/assets/34672301/5b631030-30b3-4cbb-bfc4-2064b40b90c0">
</div>

4. 루트 노드를 제외한 각 노드의 키의 개수 범위는 다음과 같음
```
t - 1 <= 키의 수 <= 2t - 1
```
5. 삽입 시 : 키의 개수를 2t - 1 개를 초과하면, 분할을 통해 규칙을 유지
   - 즉, 2t가 되면, 분할을 통해 규칙을 유지
   - 즉, 키의 삽입으로 인해 키의 개수가 2t가 되면, 노드가 보유할 수 있는 키의 수 최댓값 초과(Overfull Node)되어 키 보유 규칙을 위해 분할
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/3af0d8f0-d070-4e4e-8e94-cb7ede92ce52">
</div>

   - 노드가 보유하고 있는 키의 중간 값을 찾은 후, 중간 키를 부모 노드로 상승
   - 중간 키를 기준으로 좌측의 키들은 좌측 자식 노드, 우측의 키들은 우측 자식 노드로 분할

6. 삭제 시 : 키의 개수가 t - 1 개 미만이면, 회전 또는 병합을 통해 규칙을 유지
  - 키 삭제 시, 최소 키 규칙을 지키기 위해 회전 또는 병합 작업 실시하여 노드의 최소 키 보유 규칙 유지
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/1a54f352-cd27-4f3f-a0f3-4b1a604d7458">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/033ca019-b7dd-46ad-85a9-1c63725b28ce">
</div>

  - 즉, 형제 노드의 키를 빌려온 후(회전), 삭제하고자 하는 노드 삭제
  - 하지만, 형제 노드의 키를 빌려올 수 없으면(병합), 이를 병합한 후 해당 키를 삭제

7. 각 노드당 키에 따라 가질 수 있는 자식의 범위는 다음과 같음
```
t <= 자식 수 <= 2t
```
  - 노드의 키의 개수가 k개 이면, 자식 노드의 개수는 k + 1개
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/06cc4593-7598-4551-868e-edb3891ed508">
</div>

-----
### B-Tree의 탐색
-----
1. 이진 탐색 트리와 유사
2. 각 노드는 정렬된 데이터로 배치되므로 루트 노드의 키부터 자식 노드의 키까지 탐색
<div align="center">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/6f0eaa28-6165-4969-9d37-9e29a0b0c175">
<img src="https://github.com/sooyounghan/Data-Structure/assets/34672301/7accec5b-33bb-4696-a8ca-37600a26baf5">
</div>

  - 첫 번째 키에 접근하여 찾아야하는 키와 해당 키의 값 비교
  - 찾아야 하는 키보다 큰 값을 만나면, 해당 Key Index에 해당하는 자식 노드로 내려가 탐색하여, 다시 첫 번째 키부터 접근해 탐색
